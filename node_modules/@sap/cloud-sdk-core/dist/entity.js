"use strict";
/*!
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var entity_builder_1 = require("./entity-builder");
var selectable_1 = require("./selectable");
var util_1 = require("./util");
var name_converter_1 = require("./util/name-converter");
/**
 * Super class for all representations of OData entity types.
 */
var Entity = /** @class */ (function () {
    function Entity() {
        util_1.nonEnumerable(this, '_customFields');
        this._customFields = {};
    }
    Entity.entityBuilder = function (entityConstructor) {
        var builder = new entity_builder_1.EntityBuilder(entityConstructor);
        entityConstructor._allFields.forEach(function (field) {
            var fieldName = "" + name_converter_1.toPropertyFormat(field.fieldName);
            builder[fieldName] = function (value) {
                this.entity[fieldName] = value;
                return this;
            };
        });
        return builder;
    };
    Entity.customFieldSelector = function (fieldName, entityConstructor) {
        return new selectable_1.CustomField(fieldName, entityConstructor);
    };
    Object.defineProperty(Entity.prototype, "versionIdentifier", {
        /**
         * ETag version identifier accessor.
         *
         * @returns {string} The ETag version identifier of the retrieved entity, returns undefined if not retrieved
         */
        get: function () {
            return this._versionIdentifier;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a map that contains all entity custom fields.
     *
     * @returns {MapType<any>} A map of all defined custom fields in the entity
     */
    Entity.prototype.getCustomFields = function () {
        return this._customFields;
    };
    /**
     * Custom field value getter.
     *
     * @param fieldName The name of the custom field
     * @returns {any} The value of the corresponding custom field
     */
    Entity.prototype.getCustomField = function (fieldName) {
        return this._customFields[fieldName];
    };
    /**
     * Sets a new custom field in the entity or updates it.
     * Throws an error, if the provided custom field name is already defined by an original field in entity.
     *
     * @param fieldName The name of the custom field to update
     * @param value The value of the field
     * @returns {this} The entity itself, to facilitate method chaining
     */
    Entity.prototype.setCustomField = function (fieldName, value) {
        if (this.isConflictingCustomField(fieldName)) {
            throw new Error("The field name \"" + fieldName + "\" is already defined in the entity and cannot be set as custom field.");
        }
        this._customFields[fieldName] = value;
        return this;
    };
    /**
     * Validates whether a custom field exists in the entity.
     *
     * @param fieldName The name of the custom field to update
     * @returns {boolean} A boolean value, that indicates whether a custom field is defined in entity
     */
    Entity.prototype.hasCustomField = function (fieldName) {
        return this._customFields[fieldName] !== undefined;
    };
    /**
     * Sets all retrieved custom fields in entity.
     *
     * @param customFields Extracted custom fields from a retrieved entity
     * @returns {this} A boolean value, that indicates the existence of the field in entity
     */
    Entity.prototype.initializeCustomFields = function (customFields) {
        var _this = this;
        Object.entries(customFields).forEach(function (cf) {
            _this.setCustomField(cf[0], cf[1]);
        });
        return this;
    };
    /**
     * Set the ETag version identifier of the retrieved entity.
     *
     * @param etag The returned ETag version of the entity
     * @returns {this} The entity itself, to facilitate method chaining
     */
    Entity.prototype.setVersionIdentifier = function (etag) {
        if (etag && typeof etag === 'string') {
            util_1.nonEnumerable(this, '_versionIdentifier');
            this._versionIdentifier = etag;
        }
        return this;
    };
    /**
     * Initializes or sets the remoteState of the entity.
     * This function is called on all read, create and update requests.
     * This function should be called after [[initializeCustomFields]], if custom fields are defined.
     *
     * @param state State to be set as remote state
     * @returns {this} The entity itself, to facilitate method chaining
     */
    Entity.prototype.setOrInitializeRemoteState = function (state) {
        var _this = this;
        if (state === void 0) { state = null; }
        if (!state || !this.remoteState) {
            util_1.nonEnumerable(this, 'remoteState');
            this.remoteState = {};
            Object.assign(this.remoteState, this.getCurrentMapKeys());
        }
        else {
            Object.keys(state).forEach(function (field) {
                if (_this[name_converter_1.toPropertyFormat(field)]) {
                    _this.remoteState[name_converter_1.toPropertyFormat(field)] = state[field];
                }
                else {
                    // we store the custom field with its original name in the remote state
                    _this.remoteState[field] = state[field];
                }
            });
        }
        return this;
    };
    /**
     * Returns all updated custom field properties compared to the last known remote state.
     *
     * @returns {MapType<any>} A map containing all updated custom properties, with their new values
     */
    Entity.prototype.getUpdatedCustomFields = function () {
        var _this = this;
        if (this.remoteState === undefined) {
            return this._customFields;
        }
        var patch = {};
        var current = this.getCurrentMapKeys();
        Object.keys(this.getCustomFields()).forEach(function (fieldName) {
            if (_this.remoteState[fieldName] !== current[fieldName]) {
                patch[fieldName] = current[fieldName];
            }
        });
        return patch;
    };
    /**
     * Returns all changed properties compared to the last known remote state.
     * The returned properties does not include custom fields. Use [[getUpdatedCustomFields]], if updated custom fields are needed.
     *
     * @returns {Entity} Entity with all properties that changed
     */
    Entity.prototype.getUpdatedProperties = function () {
        var _this = this;
        var current = this.getCurrentMapKeys();
        if (this.remoteState === undefined) {
            return current;
        }
        var patch = {};
        Object.keys(current)
            .filter(function (key) { return _this.propertyIsEnumerable(key); })
            .filter(function (key) { return !_this.hasCustomField(key); })
            .forEach(function (key) {
            if (_this.remoteState[key] !== current[key]) {
                patch[key] = current[key];
            }
        });
        return patch;
    };
    /**
     * Returns a map of all defined fields in entity to their current values.
     *
     * @returns {Entity} Entity with all defined entity fields
     */
    Entity.prototype.getCurrentMapKeys = function () {
        var _this = this;
        var map = {};
        Object.keys(this)
            .filter(function (key) { return _this.propertyIsEnumerable(key); })
            .forEach(function (key) {
            map[key] = _this[key];
        });
        Object.entries(this.getCustomFields()).forEach(function (customField) {
            map[customField[0]] = customField[1];
        });
        return map;
    };
    /**
     * Validates whether a field name does not conflict with an original field name and thus can be defined as custom fields.
     *
     * @param customFieldName Field name to check
     * @returns {boolean} Boolean value that describes whether a field name can be defined as custom field
     */
    Entity.prototype.isConflictingCustomField = function (customFieldName) {
        return this[name_converter_1.toPropertyFormat(customFieldName)] !== undefined;
    };
    return Entity;
}());
exports.Entity = Entity;
// tslint:disable: valid-jsdoc
/**
 * @hidden
 */
function isSelectedProperty(json, selectable) {
    return json.hasOwnProperty(selectable.fieldName);
}
exports.isSelectedProperty = isSelectedProperty;
/**
 * @hidden
 */
function isExistentProperty(json, link) {
    return isSelectedProperty(json, link) && json[link.fieldName] !== null;
}
exports.isExistentProperty = isExistentProperty;
/**
 * @hidden
 */
function isExpandedProperty(json, link) {
    return isExistentProperty(json, link) && !json[link.fieldName].hasOwnProperty('__deferred');
}
exports.isExpandedProperty = isExpandedProperty;
//# sourceMappingURL=entity.js.map