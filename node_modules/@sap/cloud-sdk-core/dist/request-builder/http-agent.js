"use strict";
/*!
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = __importStar(require("http"));
var http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
var https = __importStar(require("https"));
function getAgentConfig(destination) {
    var protocol = getUrlProtocol(destination);
    if (protocol === Protocol.HTTP) {
        return { httpAgent: createAgent(destination, Protocol.HTTP) };
    }
    else if (protocol === Protocol.HTTPS) {
        return httpsAgentConfig(destination);
    }
    else if (destination.url && !protocol) {
        console.warn("URL of the provided destination (" + destination.url + ") has no protocol specified! Assuming HTTPS.");
        return httpsAgentConfig(destination);
    }
    else {
        throw new Error("Protocol of the provided destination (" + protocol + ") is not supported! Currently only HTTP and HTTPS are supported.");
    }
}
exports.getAgentConfig = getAgentConfig;
var httpsAgentConfig = function (destination) { return ({ httpsAgent: createAgent(destination, Protocol.HTTPS) }); };
function createAgent(destination, protocol) {
    if (!protocol) {
        protocol = getUrlProtocol(destination) || Protocol.HTTPS;
    }
    if (destination.proxyConfiguration) {
        if (destination.isTrustingAllCertificates === true) {
            console.warn('The destination is configured to both use a proxy and to trust all certificates. This is currently not supported. The proxy configuration will be applied, but certificates will be tried to validate.');
        }
        return proxyAgent(destination.proxyConfiguration.host, destination.proxyConfiguration.port);
    }
    else if (destination.isTrustingAllCertificates === true && protocol === Protocol.HTTPS) {
        console.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        return trustAllAgent();
    }
    else if (destination.isTrustingAllCertificates === true && protocol === Protocol.HTTP) {
        console.warn('"isTrustingAllCertificates" header agent is not available for requests across "HTTP" URL protocol.');
    }
    return defaultAgent(protocol);
}
exports.createAgent = createAgent;
function defaultAgent(protocol) {
    return protocol === Protocol.HTTP ? new http.Agent() : new https.Agent();
}
function trustAllAgent() {
    return new https.Agent({
        rejectUnauthorized: false
    });
}
function proxyAgent(proxyHost, proxyPort) {
    return new http_proxy_agent_1.default("http://" + proxyHost + ":" + proxyPort);
}
exports.proxyAgent = proxyAgent;
function getUrlProtocol(destination) {
    return getProtocol(destination.url);
}
exports.getUrlProtocol = getUrlProtocol;
var Protocol;
(function (Protocol) {
    Protocol["HTTP"] = "http";
    Protocol["HTTPS"] = "https";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
function getProtocol(uri) {
    if (uri) {
        var urlParts = uri.toLowerCase().split('://');
        if (urlParts.length > 1) {
            return urlParts[0];
        }
    }
}
//# sourceMappingURL=http-agent.js.map